\documentclass[10pt, a4paper]{article}

\input{includes}

\title{Rapport}
\author{GOEDEFROIT Charles}
\subject{Sur l'article : Arbitration Policies for On-Demand User-Level I/O Forwarding on HPC Platforms}
\keywords{}
\date{\today}

\input{configs}

\begin{document}

\begin{titlepage}
	\centering
  \ {} % important
	\vfill
	\vspace{1cm}
	{\scshape\Huge\MyTitle\par}
	\vspace{0.5cm}
	{\Large\MySubject\par}
	\vspace{1cm}
	\MyAuthor
	\vfill
	{\large\MyDate\par}
\end{titlepage}

\newpage

\section{L'objectif de l'article}

L'objectif de l'article est d'améliorer l'utilisation de la bande passante entre les \noeudsDeCalculs{} et les \emph{noeuds de stockage des données}, que j'appellerai \noeudsIO{} dans le reste de ce rapport. Plus précisément, l'objectif est de permettre le changement dynamique des politiques d'accès aux \noeudsIO{}. Pour cela, l'article propose :
\begin{itemize}
  \item une implémentation qui permet ce changement en fonction des patterns d'accès aux \noeudsIO{}.
  \item ainsi qu'une politique basé sur le problème du sac à dos à choix multiple \emph{Multiple-Choice Knapsack problem}.
\end{itemize}

Il propose aussi une solution qui permet d'utiliser dynamiquement différentes politiques d'allocation de \emph{noeuds I/O forwarding}.

\section{Le context de l'article}

Cet article se place dans le contexte ou les supercalculateurs font de plus en
plus d'accès aux données. Cette augmentation est due à plusieurs facteurs comme :
\begin{itemize}
  \item l'augmentation de la puissance de calcul.
  \item l'augmentation des quantités de données a traité.
  \item la variété des types d'applications à accès hétérogénéité aux données, l'intelligence artificielle, le bigData\dots
\end{itemize}
Pour répondre au besoin de puissance croissante, on augmente le nombre de \noeudsDeCalculs{} ce qui a pour effet d'augmenter le nombre de requêtes système de fichier parallèle (\emph{PFS}). Ce système fini par ne plus pouvoir traité autant de requêtes, car tous les \noeudsIO{} se retrouvent saturés. Pour réglé ce problème les \emph{PFS} utilise la technique du \emph{I/O forwarding} qui diminue le nombre de noeuds du \emph{PFS} accessible par les \noeudsDeCalculs{}.

\subsection{La technique du \emph{I/O forwarding}}

Cette technique est très utilisée pour le calcul haut performance, notamment par des machines du top 500\cite{}. Elle permet d'augmenter les performances globales en diminuant la concentration des requêtes sur les \noeudsIO{}. Pour cela, elle évite les accès directs aux \noeudsIO{} en se plaçant entre les \noeudsDeCalculs{} et les \noeudsIO{}. Concrètement, un groupe de \noeudsIO{} reçoit les requêtes et appliquent des traitements avant de les transmettre aux bons \noeudsIO{}. Cette technique est transparente pour les utilisateurs, elle cherche à appliquer une répartition uniforme entre les noeuds et permet le contrôle des demandes d'accès aux données ce qui permet l'application de technique d'optimisation. Ces techniques peuvent être de différentes natures comme l'agrégation des requêtes (en combinant plusieurs petites requêtes) ou la planification des requêtes.

Habituellement les \noeudsIO{} qui s'occupent de la réception des requêtes sont assigné statiquement à un \noeudDeCalculs{} et celle-ci peut dépendre de la topologie du réseau, du nombre de \noeudsIO{}\dots Cette assignation ne correspond pas tout le temps au besoin de l'application qui peut ne pas utiliser toute la bande passante ou être ralentie par celle-ci. L'assignation statique amène donc à une mauvaise utilisation des ressources. Dans la suite du rapport, j'appellerai les \noeudsIO{} qui s'occupent de la réception les \emph{noeuds I/O Forwarding}.

\section{Le problème traité par l'article}

L'article cherche à corriger les problèmes de l'allocation statique en proposant une allocation dynamique.
Les problèmes de l'allocation statique sont :
\begin{itemize}
  \item Le nombre de \noeudsIO{} et prédéfinis et donc ne peut pas changer pendant l'exécution ou s'adapter à une application.
  \item Ce n'est pas flexible, car la politique d'allocation des \noeudsIO{} reste la même tout au long de l'exécution.
  \item On peut être amené à de mauvaises allocations des ressources (L'article cite les travaux de Yu et al. [8] Bez et al. [9])\cite{}.
  \item En fonction de l'application, on peut ce retrouvé avec une bande passante peu utiliser ou qui ralentit l'application. Ce qui fait qu'on utilise pas assez ou trop de \noeudsIO{}.
  \item Ne permets pas le changement facile de la stratégie d'allocation sans avoir un mauvais impacte sur les performances.
\end{itemize}

\subsection{Évaluations des politiques d'allocations}

Dans l'article, ils ont commencé par évaluer les politiques d'allocation suivante :
\begin{itemize}
  \item \emph{ZERO and ONE Policies} chaque application à 0 ou un \noeudIO{} alloué.
  \item \emph{STATIC Policy} le nombre de \noeudsIO est déterminé par rapport au nombre de \noeudsDeCalculs{}.
  \item \emph{SIZE and PROCESS Policies} le nombre de \noeudsIO est réparti proportionnellement entre les applications par rapport à leur nombre de \noeudsDeCalculs{} ou leur nombre de processus.
  \item \emph{ORACLE Policy} chaque application se voit allouer un nombre de \noeudsIO qui maximise l'utilisation de la bande passante. Cette allocation est déterminée par une évaluation des performances.
\end{itemize}

Ils ont effectué ces évaluations en faisant plusieurs lancements avec différents nombres de \noeudsIO, différentes politiques d'allocation et avec différentes applications pour avoir différents patterns d'accès au \emph{PFS}. Ces évaluations, ont été effectuées sur le supercalculateur \emph{MareNostrum 4} (\emph{MN4}) en utilisant un outil appelé FORGE (I/O \textbf{For}wardin\textbf{g E}xplorer) qui permet de relancer les profils \emph{I/O} des applications.

Pour obtenir les résultats, ils ont fait des traces pour connaître les patterns d'accès des applications au \emph{PFS}. Ils ont collecté le volume total des données transféré et le nombre de processus qui font des requêtes \emph{I/O}. Avec ces traces, ils ont créé des petits benchmarks pour reproduire les patterns d'accès et faire des tests de performance.

Ils n'ont pas eu besoin de faire de profiling, car ils ne s'intéressent qu'aux politiques d'allocation.

Ils ont exécuté 189 patterns sur la machine \emph{MN4} et ils ont fait des groupes de 16 patterns pour simuler chaque politique (Un pattern représente une application).
Ils ont donc généré 10 000 groupes de 16 patterns qui prennent le même temps d'exécution.
Ils ont utilisé jusqu'à 128 \emph{noeuds I/O forwarding}, 8 par application ($128/16=8$). Avec un nombre de \noeudsDeCalculs{} entre 88 et 512 et une médiane de 256.

La bande passante de chaque groupe est calculée par la somme des nombre d'écriture plus le nombre de lecture le tout divisé par le temps d'exécution. ($(nbÉcriture + nbLecture) / tempsDExécution$).
% W = Write, R = Read, runtime = runningTime
\begin{equation*}aggregate\ BW=\sum_{a=1}^{16}\left(\frac{W_{a}+R_{a}}{runtime_{a}}\right) \tag{2}\end{equation*}

Cette évaluation montre qu'il est possible d'améliorer l'utilisation de la bande passante.
Ils ont aussi vu que toutes les applications n'ont pas les mêmes performances avec le même nombre de \noeudsIO{}. Cette différence existe, car chaque application a un pattern d'accès au \emph{PFS} différent. Ils ont remarqué que certaines applications avaient des patterns similaires.

\section{Propositions de l'article}

La problématique d'une politique d'allocation peut être repésenté comme suit :
Pour un ensemble de tâches ou job à exécuter et un nombre fixe de \emph{noeud I/O} il faut déterminé le nombre de \emph{noeud I/O Forwarding} qui permet de maximisé l'utilisation de la bande passante globale.
Cette problématique peut être considéré comme un problème d'optimisation.

Pour répondre à cette problématique et permettre l'allocation dynamique l'article porpose une nouvelle politique d'allocation ainsi qu'un service permettant l'allocation dynamique.

\subsection{La politique d'allocaion basé sur \emph{MCKP}}

La politique d'allocation basé sur \textbf{MCKP} (\emph{Multiple-Choice Knapsack Problem}) cherche la mailleur répartition possible des \emph{noeud I/O Forwarding} aux \noeudsDeCalculs{}.
Pour cela cette politique cherche à maximisé la band passante global en donnant plus de \emph{noeud I/O Forwarding} au applications qui en on le plus besoin et moins au autre. Ce problème d'optimisation et dérivé du problème \emph{0-1 Knapsack}.
Pour effectué la maximisation de la band passante l'algorithms vérifie que chaque tâches à bien une taille et que le nombre globale de \emph{noeud I/O Forwarding} calculé ne dépasse pas le nombre de \emph{noeud I/O Forwarding} disponible.

Ce problème fait partie de la classe de complexité en temps \emph{NP-hard} mais une solution peut être obtenu par "Dynamic Programming" qui est en temps \emph{pseudo-polynomial}.

Le nombre de \noeudsDeCalculs{} dois être divisable par le nombre de \emph{noeud I/O Forwarding} pour améliorer l'équilibrage de la charge.

% MCKP :
% - Ce problem cherche à maximisé la bandpassat global en donnant plus de noeud I/O au applications qui en on le plus besoin.
% - un problème d'optimisation
% - derived from the 0-1 Knapsack
% - items divide in $k$ classes of $N_i$ items
% ($N$ = ensemble des nombre d'items par classes)
% $Items = {a; b; c; d; e; f; g}, k <- 2, Items/k = C <- {{a; b; c}; {d; e; f; g}},$
% $card(C_1) = 3 = N_1, card(C_2) = 3 = N_2$
% - $x_{ij} = 1$ ssi item $j$ is chosen in class $N_i$
% - $w_i$ is the weight for the iéme items that represent number of I/O nodes.
% - $W$ the total number of I/O nodes.
% - $p_i$ is the bandwidth.
% - problem is NP-hard
% - la solution es obtenu par "Dynamic Programming" qui a une complexité en temps pseudo-polynomial ($O(W\sum^{k}_{i=1}N_i)$)

\subsection{Le service permettant l'allocation dynamique (\emph{GekkoFWD})}

L'article propose un service \emph{I/O forwarding} appelé \emph{GekkoFWD} qui
implémente la politique \textbf{MCKP}. Ce service permet le changement de politiques d'allocation ainsi que le nombre de \emph{noeud I/O Forwarding} à la demande (dynamiquement) sans perturbé l'application. Il fonction au niveau utilisateur, il ne nécessite pas de modification du code des applications et il est simple à déployé. Cette simplicité en fait une solution utilie.
Ce service est basé sur \emph{GekkoFS} qui est une système de fichier local à un noeud et qui peut ce connecté à la plupart des \emph{PFS} existant.

\subsubsection{\emph{GekkoFS}}

\emph{GekkoFS} est un système de fichiers local qui est exécuter sur les \noeudsDeCalculs{}. Ce système est utilisé comme un \emph{burst-buffer}. Comme sont nom l'indique c'est un buffer qui ce met entre l'application et le \emph{PFS} dans le but d'amélioré la performances des accès \emph{I/O}. Cette amélioration est en partie du à la diminution de la charge sur le \emph{PFS} quant il y a un pics de demande.

Ce système permet aussi l'exécution des requêtes \emph{I/O en parallèle} de l'exécution du calcule, ce qui permet d'augmente l'utilisation de la band passante.

Il fourni aussi un système de nom qui est partagé entre tous les \noeudsDeCalculs{}. Ce mécanisme peut être remplacé par un \emph{PFS}.

\subsubsection{Application de technique d'optimisation (\emph{AGIOS})}

\emph{GekkoFWD} nous permet d'appliqué des techniques d'optimisation de façon transparente. Pour ce faire ils ont ajouté la bibliothèque \emph{AGIOS} dans \emph{GekkoFWD}. Cette bibliothèque fourni plusieurs algorithms d'ordonnancement.
\emph{GekkoFWD} peut donc utilisé différent ordonnanceurs sur les requêtes. Ceci permet la planification des requêtes au niveau des données.

\section{Algorithme}

Grâce à \emph{GekkoFWD}, \emph{GekkoFS} est utilisé comme un noeud intermédiaires entre les \noeudsDeCalculs{} et les \emph{noeud I/O}. Pour cela \emph{GekkoFS} capture les requêtes que fait l'application au \emph{PFS}. Cette capture est transparent et ce fait en interceptant les appéles système. Une fois les requêtes capturé \emph{GekkoFWD} transfére les requêtes à un seul serveur qui vas les passé à \emph{AGIOS} pour ordonancé le moment ou elle seront traité. Grâce au requêtes il est possible de determiné quelle politique d'allocation appliqué.

Pour savoir quant le mappage à changer on ajoute un thread grâce à \emph{GekkoFS}.

\section{Les performances}

Ils on fait les expérimentations sur la platform Grid 5000 (G5K) avec 2 cluster à Nancy : Grimoire (8 noeud) et Gros (124 noeud).

Ils ont utilisé 5 noyaux d'applications différentes ainsi que les micro-benchmark IOR :
\begin{enumerate}
  \item S3D I/O Kernel : S3D
  \item MADBench2 : MAD
  \item HACC-IO : HACC
  \item S3aSim : SIM
  \item NAS BT-IO : BT-C, BT-D
  \item [IOR] MPI-IO / POSIX : IOR-MPI, POSIX-S, POSIX-L
\end{enumerate}

Ils ont mesuré la band passant pour chaque applications et il confirme les résultat de FORGE. Ils ont fait ce test avec des nombre de noeud et des nombre de processus différent.
Les ensembles de tâches pour testé de changement d'allocation dynamique été composé de BT-C, BT-D, IOR-MPI, POSIX-L, MAD, et S3D.

Ils constate bien que les accès statique sont pas très efficace sauf pour S3D. Même constatation pour l'allocation par taille. Dans c'est 2 cas on vois que par exemple IOR-MPI pourrai être bien mailleurs avec plus de \emph{noeud I/O forwarding}. Ils constate bien un nétte ammélioration avec leur implémentation \emph{MCKP}. Le gain global d'utilisation de la band passante est jusqu'à 85\% par rapport à la politique statique.

Ils ont comparer différents sénario pour montré que leur implémentation fonctionne bien.

\section{Les article qu'il référence}
% - information about other papers that reference it.

Ils existe :/

TODO: SECTION 6.

\section{Check / Add}

TODO:

Le papier parle de :
- regarde plusieurs politique de répartition des ressources en fonction des patternes d'accées au données.
- comparé différent patterns d'accées pour mieux voir les benefices et désavantages

Le papier plaide pour :
- allocation dynamique des noeud I/O par rapport au type de calculs / patternes des application
- repartire des applications sur plusieur reources pour maximisé l'utilisation de la bande passante.
- Le changement de politique ce fait au démarrage ou au changement des applications (job) lancé. (pour déterminé le mailleur nb de I/O forwarding nodes)

1. maximize la band passante en donnant des noeud de stockage au application qui vont mieux les utilisé. (et pas au applications qui accéde peut au données?).

% load all bibliographies
\bibliography{biblio}
\nocite{*}

\end{document}

% TODO: up to 8 pages
